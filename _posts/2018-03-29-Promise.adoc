# JS에서 비동기 프로그래밍
Jisung, Ahn <narusas.gmail.com>
v1.0, 2018-03-29
:showtitle:
:page-navtitle: JS에서 비동기 프로그래밍
:page-description: JS에서 비동기 프로그래밍에 대해 이야기합니다. 
:page-root: ../../../


## Single Thread
javascript는 언어적 차원에서 단일 쓰래드만 지원합니다. 우리가 작성한 코드는 단 한줄만이 실행중인 상태입니다.  단 하나의 쓰래드에 의해서 말이죠. 

[source,javascript]
----
var a = 10;
var b = 20;

function swap(){
    var swap = a;
    a = b;    
    b = swap;
}
----

따라서 다른 언어와 달리 JS에서는 위의 코드에서 동시성 문제가 발생하지 않습니다. a와 b 변수에 동시에 접근하여 변경 하는 경우자체가 발생하지 않으니까요. 

NOTE: 네 최근에는 조금 달라졌습니다. ServiceWorker가 등장하며 제한적이나마 멀티 쓰래딩이 가능해졌습니다. 

언어 차원에서 단일 쓰래드로 정의했기 때문에 동시성 문제를 배제하고 프로그래밍 할수 있다는 것은 나쁘지 않습니다만, 이제 성능이 문제가 됩니다. 


## Performance
[source, javascript]
----
function f(){
  var text = fileUtil.readFile('a.txt');
  return parseCsv(text);
}
----

만약 a.txt의 용량이 커서 읽는데 시간이 많이 걸리면 어떻게 될까요? 사실 배치(batch) 작업에서는 크게 문제 되지 않습니다. 그냥 순서대로 실행하면 되니까요. 우리가 bash 쉘 스크립트같은 곳에서 동시성을 요구하지 않는것과 비슷합니다. 순서대로 일련의 작업을 잘 실행해주면됩니다. 

하지만 JS의 대부분은 웹 브라우저에서 동작합니다. (네 node express  잘 알고 있습니다)

웹 브라우저에서 사용자가 원하는 것은 배치 작업이 아닙니다. 사용자가 클릭하고, 편집하고, 스크롤하고, 저장하고...

동시에 많은 작업을 수행하기를 원할수 있습니다.  하지만, 동시에 시간이 걸리는 작업도 수행해야 합니다. 

이 두가지를 동시에 요청하면 JS로는 답이 나오지 않습니다.  

[source, javascript]
----
function click1(){
  var text = fileUtil.readFile('a.txt');
  return parseCsv(text);
}

function click2() {
  var text = fileUtil.readFile('b.txt');
  return parseCsv(text);
}
----

사용자가 버튼을 클릭하여 click1이 수행중인데 용량이 커서 읽어오는데 10초쯤 걸립니다. 그런데 또다른 버튼을 클릭해 click2 를 실행하려고 해도 click1이 실행중이기 때문에 click2는 10초후에 실행될 겁니다. 
순차적으로 시간을 소비하여 수행해야 하니까요. 


## Asynchronous

따라서 JS가 아닌 다른 수단이 필요해집니다.  JS자체로는 이문제를 해결할수 없습니다. 그래서 js의 실행환경을 제공하는 주변 에서 기능을 제공하게 됩니다. 

웹브라우저에서는 XmlHttpRequest 을 제공합니다. js에서 xmlHttpRequest를 호출하면 웹브라우저는 이에 대한 실행을 C Posix 쓰래드로 실행합니다! JS 쓰래드가 아니고요. (웹브라우저의 구현 언어와 라이브러리에 따라 다른 언어와 쓰래드 라이브러리를 사용할겁니다)

[source, javascript]
----
var oReq = new XMLHttpRequest();
oReq.addEventListener("load", function callback(){
    console.log('load'); // # <1>
});
oReq.open("GET", "http://www.example.org/example.txt");
oReq.send();  // # <2> 
console.log('sent!');  // # <3>
----
<2> send 함수를 호출한다고 해서 js가 동기적으로 기다리지않습니다. 그냥 요청을 한거 뿐이고 바로 <2>로 넘어갑니다. 

그럼 <1>은 언제 실행될까요?  

- C++로 만들어진 HTTP 요청 코드가 실행되어 서버에 요청을 보내고, 
- 이에대해 응답이 와서 C++로 파싱이 한후에 
- JS의 유일한 쓰래드가 현재 실행중인 코드가 없을때 
- 콜백인 <1>을 호출합니다 

이런 콜백 기반의 비동기화 방식은 다음과 같은 전제를 합니다. 

* CPU는 빠르다.
* IO는 느리다. 
* 따라서 IO는 JS에서 하지말고, CPU에 관련된 것은 JS로 하자. 

여전히 JS는 단일 쓰래드입니다. 하지만 IO 때문에 느려지는것은 회피할수 있게 되었습니다. 

웹브라우저상에서 이런식으로 사용할수 있는 비동기 콜백은 과거에는 setTimeout, XmlHttpRequest 정도 였습니다. 

하지만 ES5


